import time

from numpy.create import ones, array, zeros_like

from sequre.types.sharetensor import Sharetensor
from sequre.types.multiparty_partition import MPP
from sequre.types.multiparty_union import MPU
from sequre.utils.testing import assert_eq, assert_eq_approx
from sequre.utils.utils import random_floats
from sequre.mpc.env import MPCEnv
from sequre.stdlib.learn.log_reg import LogReg


def test_log_reg[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre logistic regression on {alg_struct} ... \n')

    rows_per_party = 4
    cols_per_party = 15
    with mpc.randomness.seed_switch(-1):
        X = array(random_floats(((mpc.comms.number_of_parties - 1) * rows_per_party, cols_per_party), scale=3)) - 1.5
        target_w = array(random_floats((cols_per_party, 1), scale=1))
        y = (X @ target_w).sign()
    target_w = target_w.vstack(array([[0.0]]))

    mpc_X = Sharetensor.enc(mpc, X, 0, modulus)
    mpc_y = Sharetensor.enc(mpc, y, 0, modulus)
    
    mpp_X = MPP(mpc, zeros_like(X) if mpc.pid == 0 else X[(mpc.pid - 1) * rows_per_party:mpc.pid * rows_per_party])
    mpp_y = MPP(mpc, zeros_like(y) if mpc.pid == 0 else y[(mpc.pid - 1) * rows_per_party:mpc.pid * rows_per_party])

    mpu_X = MPU(mpc, mpp_X._local_data, "partition")
    mpu_y = MPU(mpc, mpp_y._local_data, "partition")

    mpc.comms.sequential(lambda: print(f"CP{mpc.pid}:\tLogistic regression train data for debugging on {alg_struct}:", X), False)
    if mpc.pid > 0:
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking logistic regression data loading (MPC) on {alg_struct}", mpc_X.reveal(mpc), X)
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking logistic regression data loading (MPP) on {alg_struct}", mpp_X.reveal(mpc), X)
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking logistic regression data loading (MPU) on {alg_struct}", mpu_X.reveal(mpc), X)

    step_size = 0.001
    epochs = 2

    features_size = cols_per_party + 1
    raw_initial_w = ones((features_size, 1))
    mpc_initial_w = Sharetensor.enc(mpc, raw_initial_w, 0, modulus)
    
    s = time.time()
    raw_log_reg = LogReg(raw_initial_w, optimizer="bgd").fit(mpc, X=X, y=y, step=step_size, epochs=epochs)
    e = time.time()
    plaintext_time = e - s
    print(f'CP{mpc.pid}:\tRuntimes:\n\t\tPlaintext: {plaintext_time}s\n')

    s = time.time()
    mpc_log_reg = LogReg(mpc_initial_w).fit(mpc, X=mpc_X, y=mpc_y, step=step_size, epochs=epochs)
    e = time.time()
    mpc_time = e - s
    print(f'CP{mpc.pid}:\tRuntimes:\n\t\tMPC: {mpc_time}s\n')

    raw_w = raw_log_reg.coef_
    mpc_w = mpc_log_reg.coef_

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking logistic regression result shape (MPC) on {alg_struct}", mpc_w.shape, list(raw_w.shape))
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre logistic regression (MPC) on {alg_struct}", mpc_w.reveal(mpc), raw_w)
    
    mpp_initial_w = MPP(
        mpc, zeros_like(raw_initial_w) if mpc.pid == 0 else raw_initial_w[
            (mpc.pid - 1) * features_size // (mpc.comms.number_of_parties - 1):mpc.pid * features_size // (mpc.comms.number_of_parties - 1)])
    
    mpu_initial_w = MPU(mpc, raw_initial_w if mpc.pid == 1 else zeros_like(raw_initial_w), "aggregate")
    
    s = time.time()
    mpu_log_reg = LogReg(mpu_initial_w).fit(mpc, X=mpu_X, y=mpu_y, step=step_size, epochs=epochs)
    e = time.time()
    mpu_via_mpa_time = e - s
    print(f'CP{mpc.pid}:\tRuntimes:\n\t\tMPU/MPA: {mpu_via_mpa_time}s\n')
    
    mpu_w = mpu_log_reg.coef_

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking logistic regression result shape (MPU via MPA weights) on {alg_struct}", mpu_w.shape, raw_w.shape)
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre logistic regression (MPU via MPA weights) on {alg_struct}", mpu_w.reveal(mpc), raw_w, error=5.0)  # Figure out why this test fails when error is removed. Probably in sqrt.
    
    mpu_initial_w = MPU(mpc, mpp_initial_w._local_data, "partition")
    
    s = time.time()
    mpu_log_reg = LogReg(mpu_initial_w).fit(mpc, X=mpu_X, y=mpu_y, step=step_size, epochs=epochs)
    e = time.time()
    mpu_via_mpp_time = e - s
    print(f'CP{mpc.pid}:\tRuntimes:\n\t\tMPU/MPP: {mpu_via_mpp_time}s\n')
    
    mpu_w = mpu_log_reg.coef_

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking logistic regression result shape (MPU via MPP weights) on {alg_struct}", mpu_w.shape, raw_w.shape)
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre logistic regression (MPU via MPP weights) on {alg_struct}", mpu_w.reveal(mpc), raw_w, error=5.0)  # Figure out why this test fails when error is removed. Probably in sqrt.

    print(f'CP{mpc.pid}:\tSequre logistic regression on {alg_struct} tests passed.\n')
    print(f'CP{mpc.pid}:\tRuntimes:\n\t\tPlaintext: {plaintext_time}s\n\t\tMPC: {mpc_time}s\n\t\tMPU/MPA: {mpu_via_mpa_time}s\n\t\tMPU/MPP: {mpu_via_mpp_time}s\n')
    